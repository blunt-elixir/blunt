defmodule Blunt.Message.Changeset do
  @moduledoc false

  alias Ecto.Changeset
  alias Blunt.Message.{Input, Metadata}
  alias Blunt.Message.Schema.BuiltInValidations
  alias Blunt.Message.Changeset, as: MessageChangeset

  def generate do
    quote location: :keep, generated: true do
      @doc false
      def changeset(values, opts \\ [])
          when is_list(values) or is_map(values) or is_struct(values) do
        changeset_with_discarded_data(values, opts) |> elem(0)
      end

      def changeset_with_discarded_data(values, opts \\ [])
          when is_list(values) or is_map(values) or is_struct(values) do
        MessageChangeset.changeset(%__MODULE__{}, values, opts)
      end
    end
  end

  @type message :: atom()
  @type discarded_data :: map()
  @type changeset :: Ecto.Changeset.t()
  @type values :: maybe_improper_list | map | struct

  @spec changeset(message(), values(), keyword()) :: {changeset, discarded_data} | changeset

  def changeset(message, values, opts \\ [])

  def changeset(message, values, opts) when is_struct(values),
    do: changeset(message, Map.from_struct(values), opts)

  def changeset(%{__struct__: message}, values, opts) when is_list(values) or is_map(values),
    do: changeset(message, values, opts)

  def changeset(message_module, values, opts) when is_list(values) or is_map(values) do
    fields = Metadata.field_names(message_module)
    required_fields = Metadata.field_names(message_module, :required)
    static_fields = Metadata.field_names(message_module, :static) |> Enum.map(&to_string/1)

    values =
      values
      |> Input.normalize(message_module)
      |> set_defaults_for_required_fields(message_module)
      |> autogenerate_fields(message_module)
      |> message_module.before_validate()
      |> Enum.reject(fn {name, _value} -> name in static_fields end)
      |> Enum.into(%{})

    embeds = message_module.__schema__(:embeds)

    discarded_data =
      values
      |> Map.drop(Enum.map(fields, &to_string/1))
      |> Map.drop(Enum.map(embeds, &to_string/1))

    changeset =
      message_module
      |> struct()
      |> Changeset.cast(values, fields -- embeds)

    opts = opts |> List.wrap() |> Keyword.new()
    {type, opts} = Keyword.pop(opts, :type, :schema)
    embed_changeset = {__MODULE__, :changeset, [Keyword.put(opts, :type, :embed)]}

    changeset =
      embeds
      |> Enum.reduce(changeset, &Changeset.cast_embed(&2, &1, with: embed_changeset))
      |> Changeset.validate_required(required_fields)
      |> run_built_in_validations(message_module)
      |> message_module.handle_validate(opts)

    case type do
      :embed -> changeset
      :schema -> {changeset, discarded_data}
    end
  end

  defp set_defaults_for_required_fields(values, message_module) do
    required_fields =
      message_module
      |> Metadata.fields(:required)
      |> Enum.map(fn {name, _, opts} -> {to_string(name), Keyword.get(opts, :default)} end)
      |> Enum.reject(&(elem(&1, 1) == nil))
      |> Enum.into(%{})

    Map.merge(values, required_fields, fn
      _, nil, default_value -> default_value
      _, incoming_value, _default_value -> incoming_value
    end)
  end

  defp run_built_in_validations(changeset, message) do
    message
    |> Metadata.built_in_validations()
    |> Enum.reduce(changeset, &BuiltInValidations.run/2)
  end

  defp autogenerate_fields(values, message) do
    message
    |> Metadata.autogenerated_fields()
    |> Enum.into(%{}, &run_autogenerator(&1, message))
    |> Map.merge(values)
  end

  defp run_autogenerator({name, {m, f}}, message),
    do: run_autogenerator({name, {m, f, []}}, message)

  defp run_autogenerator({name, {m, f, a}}, message) do
    unless function_exported?(m, f, length(a)) do
      raise Blunt.Message.Error,
        message: "#{inspect(message)}.#{name} autogenerate function '#{inspect(m)}.#{f}/#{length(a)}' not found."
    end

    {to_string(name), apply(m, f, a)}
  end

  def format_errors(changeset) do
    Changeset.traverse_errors(changeset, fn {message, opts} ->
      Regex.replace(~r"%{(\w+)}", message, fn _, key ->
        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
      end)
    end)
  end
end
